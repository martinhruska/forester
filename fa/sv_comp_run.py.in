#! /usr/bin/python3

import argparse
import fileinput
from functools import reduce
from functools import partial
import hashlib
import sys
import os
import re
import subprocess
import resource

TRACE_PARAM = 'trace'
FILE_PARAM = 'file'
PROPERS_PARAM = 'properties'
FALSE_PARAM = 'false'
TIME_PARAM = 'time'

PROP_SUFFIX = '.prp'
ALL_PRP = 'ALL'+PROP_SUFFIX
PROP_REGEXP = 'CHECK\s*\(\s*init\s*\(([^\)]*\))\s*\),\s*LTL\s*\((.*)\s*\)\s*\)'
INIT_IND = 1
PROP_IND = 2

GCC_HOST='@GCC_HOST@'
GCC_PLUG='@GCC_PLUG@'
TOP_DIR=os.path.dirname(os.path.dirname('@GCC_PLUG@'))
GCC_OPT=os.path.join(TOP_DIR, 'include', "forester-builtins")

TIME_REGEXP = '.*clEasyRun\(\)\ took\ ([^s]*)s'

# these constants are used only as the keys for PROPS_DICT
VALID_CALL     = 'call'
VALID_FREE     = 'valid-free'
VALID_DEREF    = 'valid-deref'
VALID_MEMTRACK = 'valid-memtrack'
IGNORED        = 'ignored' # ignored Forester warnings

REAL       = 'Is real'
SPURIOUS   = 'Is spurious'

PROPS_DICT                 = {}
PROPS_DICT[VALID_CALL]     = ['error called', 'noreturn function called']
PROPS_DICT[VALID_FREE]     = [] # TODO invalid free
PROPS_DICT[VALID_DEREF]    = ['dereferenced value is not a valid reference']
PROPS_DICT[VALID_MEMTRACK] = ['garbage detected']

def parseParams(params):
    parser = argparse.ArgumentParser(description='SV-Comp options: Task file, properties and output trace')
    parser.add_argument('--'+TRACE_PARAM, type=str, required=True,
                       help='Path to a file where output trace file will be stored')

    parser.add_argument(FILE_PARAM, type=str,
                       help='File with program for verification')

    parser.add_argument('--'+PROPERS_PARAM, type=str,
                       help='Path to a file with properties to be verified. Default is defined by the rules of the competition')
    
    parser.add_argument('--'+FALSE_PARAM, action='store_true',
                       help='Print FALSE when a bug found (this parameter is obsolete, do not use it)')
    
    parser.add_argument('--'+TIME_PARAM, action='store_true',
                       help='Print consumed CPU time')

    return vars(parser.parse_args(params))

def getPropertyFile(filePath):
    if os.path.isfile(filePath+PROP_SUFFIX):
        return filePath+PROP_SUFFIX
    else:
        dirname = os.path.dirname(filePath)
        if not os.path.isfile(os.path.join(dirname, ALL_PRP)):
                raise Exception('Properties file ' + os.path.join(dirname, ALL_PRP) + ' does not exists')
        else:
            return os.path.join(dirname, ALL_PRP)

def checkProperty(prop, lines):
    ff = lambda acc, line: acc + (1 if any(i in line for i in PROPS_DICT[prop]) else 0)
    return reduce(ff, lines, 0) > 0

def propersHold(props, lines):
    ff = lambda acc, prop: acc or checkProperty(prop, lines)
    return not reduce(ff, props, False)

def getProperty(props, lines):
    for prop in props:
        if checkProperty(prop, lines):
            return prop
    return None

def getProperties(props, lines):
    res = []
    for prop in props:
        if checkProperty(prop, lines):
            res.append(prop)
    return res

def parseProps(formulas):
    return map(lambda x: x.split()[1] if VALID_CALL not in x else VALID_CALL, formulas)

def md5sum(filename):
    with open(filename, mode='rb') as f:
        d = hashlib.md5()
        for buf in iter(partial(f.read, 128), b''):
            d.update(buf)
    return d.hexdigest()

def execute(args):
    # Parse properties
    if args[PROPERS_PARAM] == None:
        args[PROPERS_PARAM] = getPropertyFile(args[FILE_PARAM])
    reg = re.compile(PROP_REGEXP)
    specification = ""
    with open(args[PROPERS_PARAM], 'r') as f:
        lines = f.readlines()
        specification = ''.join(lines)
        props = [(x.group(INIT_IND), x.group(PROP_IND)) for x in filter(lambda x: x is not None, [reg.match(y) for y in lines]) ]
    inits = [x[0] for x in props]
    formulas = [x[1] for x in props]
    # execute Forester
    plugin_ops = '-fplugin-arg-libfa-args=print-trace-svcomp;trace-file:'+args[TRACE_PARAM] # Note options has to end with space
    p = subprocess.Popen([GCC_HOST, "-I",GCC_OPT+" -o /dev/null -O0 -DFORESTER -m32","-fplugin="+GCC_PLUG, plugin_ops,
        args[FILE_PARAM]], stderr=subprocess.PIPE)
    p.wait()

    res=0
    with p.stderr as f:
        lines = [l.decode() for l in f.readlines()]
        okf = lambda acc,x : acc or "The program is SAFE." in x
        ff = lambda acc,x : acc or "FORESTER INTERNAL ERROR" in x or "Segmentation fault" in x or "internal compiler error" in x
        spuriousf = lambda acc,x : acc or SPURIOUS in x
        prop = getProperty(parseProps(formulas), lines)
        if reduce(okf, lines, False) and not prop == VALID_MEMTRACK:
            print("TRUE")
        elif reduce(ff, lines, False) or propersHold(parseProps(formulas), lines) or reduce(spuriousf, lines, False):
            res=2
            print("UNKNOWN")
        else:
            res=1
            if prop is None or prop not in [VALID_FREE, VALID_DEREF, VALID_MEMTRACK]:
                print("FALSE")
            else:
                if VALID_MEMTRACK in getProperties(parseProps(formulas), lines):
                    print("FALSE("+VALID_MEMTRACK+")")
                else:
                    print("FALSE("+prop+")")

    md5hash = md5sum(args[FILE_PARAM])
    with fileinput.FileInput(args[TRACE_PARAM], inplace=True, backup='.bak') as tracefile:
        for line in tracefile:
            print(line.replace('<__SPECIFICATION__>', specification.rstrip('\n')).replace('<__PROGRAMHASH__>', md5hash), end='')

    if args[TIME_PARAM]:
        print(resource.getrusage(resource.RUSAGE_CHILDREN)[0])
    return res

def run():
    args = parseParams(sys.argv[1:])
    assert (TRACE_PARAM in args and FILE_PARAM in args)
    execute(args)
run()
